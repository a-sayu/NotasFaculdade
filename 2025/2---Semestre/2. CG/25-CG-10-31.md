# 25-CG-10-31

Excalidraw: [[|Excalidraw]]

## Slide: [[25-CG-Aula24.pdf|Transformações]]

---

Transformações

O processo de transformação para produção de uma determinada cena é análogo à uma fotografia obtida com uma câmera.

1. Montar o tripé e apontar a câmera à cena, que é a transformação de visualização.
2. Organizar a cena a ser fotografada, que é a modelagem da transformação.
3. Escolha de uma lente da câmera, a transformação da projeção.
4. Determinar o tamanho da fotografia final - por exemplo, no caso de uma fotografia maior que a cena original, que é a transformação de viewport.

Após estes passos, a foto seria feita, e a cena seria desenhada.

Transformações de Objetos

As três rotinas de OpenGL para modelar transformações são:

glTranslate*()
glRotate*()
glScale*()

OpenGL executa estas transformações através de profuto de matrizes (combinadas em uma única matriz)

Rotação

A rotação usa `glRotatef(angulo, x, y, z)`

Rotação de `angulo` graus ao redor do eixo definido pelo vetor x, y, z no sentido anti-horário.

Ex: `glRotatef(45.0, 0.0, 0.0, 1.0)`
Rotaciona um objeto num ângulo de 45°

Translação

A translação usa `glTranslatef(Tx, Ty, Tz)`, tornando o capaz de mover Tx, Ty, Tz da posição inicial do objeto.

Escala

A escal usa glScalef(Ex, Ey, Ez), mudando o formato de acordo com os formatos.

Ex: `glScalef(2.0, -0.5, 1.0)`
Neste exemplo, o objeto ganha o dobro de x, metada negativa de y e contina no mesmo tamanho para o z.

Transformação de Visualização

Para alcançar uma certa composição de cena na imagem final ou move-se a câmera, ou mode-se o objeto na direção oposta.

Os comandos de transformação de visualização devem ser chamados antes de qualquer execução de transformações de modelagem.

O comando no OpenGL é `gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)`

O ponto de vista é dado por eyeX, eyeY e eyeZ - indicando onde está o olho - e centerX, centerY, centerZ - que é para onde está olhando.

O upX, upY e upZ indicam a direção que é para cima, câmera para cima ou deitada.

Trasnformação de Projeção

A trasformação de projeção define um volume de visualização, que define como m objeto é projetado sobre a tela, usando perspectiva ou projeção ortográfica, por exemplo, e define os objetos que serão cortados da imagem final.

Projeção Perspectiva

Quanto mais longe está um objeto da câmera, menor parece em uma imagem, isto acontece porque usa-se um frustum de uma pirâmide, ou uma pirâmide sem o topo.

É muito usado para obter um grau de realismo, pois é semelhante á forma de visualização do olho humano.

O comando para definir um frustum é

```
void glFrustum(Gldouble left, Gldouble right, Gldouble bottom, Gldouble top, Gldouble near, Gldouble fat);
```

Que cria uma matriz para um frustum de visão perspectiva e multiplica pela matriz atual. O frustum do volume de visão é definido pelos parâmetros: (left, bottom, -near) e (right, top, -near) pelas coordenadas (x, y, z) específica no canto inferior esquerdo e canto de superior-direito do próximo plano de recorte. O `near` e `far` fornecem as distâncias do ponto de vista para o near e far do plano de recorte.

Eles sempre devem ser positivos.

`gluPerspective()` Também cria um volume de visão, similar ao `glFrustum()`, mas de um modo diferente.

```
void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble near, GLdouble far)
```

O comando cria uma matriz para um frustum de visão perspectiva simétrico e multiplica a matriz atual por isto. `fovy` é o ângulo do campo de visão no plano de x-z, seu valor deve estar entre (0.0, 180.0), `aspect` é a relação de aspecto do frustrum, sua largura dividida por sua altura. `near` e `far` são as distâncias entre o ponto de vista e os planos de corte, ao longo do z-eixo negativo.

Eles sempre devem ser positivos.

Projeção Ortográfica

O volume de visão é um paraleletípedo retangular, uma caixa. Diferente da projeçõa de perspectiva a distância do obteto à câmera não afeta o tamanho do objeto.

É usado para aplicações como criar plantas arquitetônicas e projetos CAD, onde é crucial manter os tamanhos atuais de objetos e ângulos entre eles da mesma forma como eles serão projetados.

`void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far)`

Este comando cria uma matriz para um volume de visão paralelo ortográfico e multiplica a matriz atual por esta. Os pontos (left, bottom, -near) e (right, top, -near) são os pontos próximos ao plano de corte, que é traçado no canto inferior esquerdo e canto de superior direito da janela de visualização, respectivamente.

Ambos near e far podem ser positivos ou negativos.

Transformação do Viewport

O viewport é a região da janela em que a imagem é desenhada. O viewport é medido em coordenadas de janela que refletem a posição relativa de pixels na tela do canto de inferior-esquerdo da janela, porém, se o viewport não é fixado, ele será todo o retângulo da janela que é aberta.

`glViewport()` é usado para escolher uma regisão de desenho menor, para por exemplo, criar visões múltiplas na mesma janela.

```
void glViewport(Glint x, Glint y, Glint width, Glint height);
```

O comando define um retângulo de pixels na janela na qual a imagem final é desenhada. O parâmetro (`x`, `y`) especificam o canto inferior-esquerdo do viewport, e `width` e `height` são o tamanho do retângulo do viewport.

Os valores de viewport iniciais são (0, 0, winWidth, winHeight), sendo winWidth e winHeight o tamanho da janela, caso não seja específicado o viewport.

Formas 3D pré-definidas no GLUT

O GLUT tem as formas geométricas pré-definidas, com tipos Solid e Wire:

- Esfera `void glut[TIPO]Sphere(Gldouble raioEsfera, GLdouble subdivisoesEmVolta, GLdouble subdivisoesAoLongo)`
- Cubo `void glut[TIPO]Cube(Gldouble tamanho)`
- Cone `void glut[TIPO]Cone(Gldouble raioBase, GLdouble altura, GLdouble subdivisoesEmVolta, GLdouble subdivisoesAoLongo)`
- Toróide `void glut[TIPO]Torus(Gldouble raioInterno, GLdouble raioExterno, GLdouble ladosSecao, GLdouble subdivisoesRadiais)`
- Dodecaedro `void glut[TIPO]Dodecahedron()`
- Octaedro `void glut[TIPO]Octahedron()`
- Tetraedro `void glut[TIPO]Tetrahedron()`
- Icosaedro `void glut[TIPO]Isocahedron()`
- Teapot `void glut[TIPO]Teapot(GLdouble tamanho)`

## Slide: [[25-CG-Aula25.pdf|Visualização Científica e de Dados]]

Ele demonstra as diferentes formas de visualização científica.

Visualização de Informação, não há uma posição determinada para todas as coisas, não há um "mapa". Para tal é necessário criatividade para inventar uma figura entendível.

O maior desafio é essa criatividade para criação do que é chamado de "metáforas".

Podemos olhar para os tipos de dados. E que apesar da validade de tipos de dados, o processamento corre numéricamente e é necessário uma conversão.

Há um gráfico da classificação de técnicas de visualização.

Técnicas 2D/3D Tradicionais

ScatterPlot, Gráfico de Barras, Gráficos de Setores, Scatter Plot 3D

Isso é ótimo para poucos atributos, mas como se faria para a visualização de mais atributos?

Coordenadas Paralelas



---

## ***log***

> *`upd`* : *note created -- 10.31*